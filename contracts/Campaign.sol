// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

// Documentation generated by Claude 3.7 (LLM)

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "./interfaces/IDefiIntegrationManager.sol";
import "./abstracts/PlatformAdminAccessControl.sol";

/**
 * @title Campaign
 * @dev Implements a crowdfunding campaign with DeFi yield generation and time-weighted yield distribution.
 *
 * This contract enables:
 * - Fundraising with a goal amount and time limit
 * - Support for contributions in multiple tokens
 * - DeFi yield generation on contributed funds
 * - Time-weighted yield distribution favoring early contributors
 * - Automatic refunds if the goal is not reached
 *
 * The time-weighted distribution system gives higher rewards to earlier contributors:
 * - First 25% of campaign: 1.5x multiplier
 * - 25-50% of campaign: 1.25x multiplier
 * - 50-75% of campaign: 1.1x multiplier
 * - Last 25% of campaign: 1.0x multiplier (no bonus)
 */
contract Campaign is Ownable, ReentrancyGuard, PlatformAdminAccessControl {
    using SafeERC20 for IERC20;

    // External contract references
    IDefiIntegrationManager public immutable defiManager;

    // Campaign token and identity
    address public campaignToken;
    bytes32 public campaignId;

    // Campaign financial parameters
    uint256 public campaignGoalAmount;
    uint256 public totalAmountRaised;
    uint256 public totalHarvestedYield;

    // Campaign timing parameters (packed for gas efficiency)
    uint64 public campaignStartTime;
    uint64 public campaignEndTime;
    uint64 public campaignDuration;
    bool public isClaimed;

    // Contributor tracking
    address[] public contributors;
    mapping(address => uint256) public contributions;
    mapping(address => uint256) public contributionTimestamps;
    mapping(address => bool) public hasBeenRefunded;
    mapping(address => bool) public hasClaimedYield;
    mapping(address => bool) public isContributor;

    // Yield distribution variables
    uint256 public totalWeightedContributions;
    mapping(address => uint256) public weightedContributions;
    bool public weightedContributionsCalculated;

    // Events
    /**
     * @dev Emitted when a contribution is made to the campaign
     * @param contributor Address of the contributor
     * @param amount Amount contributed
     */
    event Contribution(address indexed contributor, uint256 amount);

    /**
     * @dev Emitted when a refund is issued to a contributor
     * @param contributor Address of the contributor receiving the refund
     * @param amount Amount refunded
     */
    event RefundIssued(address indexed contributor, uint256 amount);

    /**
     * @dev Emitted when the campaign owner claims the raised funds
     * @param owner Address of the campaign owner
     * @param amount Amount claimed
     */
    event FundsClaimed(address indexed owner, uint256 amount);

    /**
     * @dev Emitted when funds are deposited to a yield protocol
     * @param token Address of the token deposited
     * @param amount Amount deposited
     */
    event FundsDeposited(address indexed token, uint256 amount);

    /**
     * @dev Emitted when yield is harvested from a protocol
     * @param token Address of the token yielded
     * @param creatorYield Amount of yield harvested
     */
    event YieldHarvested(address indexed token, uint256 creatorYield);

    /**
     * @dev Emitted when funds are withdrawn from a yield protocol
     * @param token Address of the token withdrawn
     * @param amount Amount withdrawn
     */
    event WithdrawnFromYield(address indexed token, uint256 amount);

    /**
     * @dev Emitted when tokens are swapped
     * @param fromToken Source token address
     * @param toToken Destination token address
     * @param amountIn Amount of source tokens
     * @param amountOut Amount of destination tokens received
     */
    event TokensSwapped(
        address indexed fromToken,
        address indexed toToken,
        uint256 amountIn,
        uint256 amountOut
    );

    /**
     * @dev Emitted when yield is distributed to a contributor
     * @param contributor Address of the contributor
     * @param amount Amount of yield distributed
     */
    event YieldDistributed(address indexed contributor, uint256 amount);

    /**
     * @dev Emitted when yield shares are calculated for all contributors
     */
    event YieldSharesCalculated();

    // Custom errors
    error InvalidAddress();
    error ContributionTokenNotSupported(address token);
    error InvalidGoalAmount(uint256 amount);
    error InvalidCampaignDuration(uint256 duration);
    error InvalidContributionAmount(uint256 amount);
    error CampaignNotActive();
    error CampaignStillActive();
    error CampaignGoalReached();
    error CampaignGoalNotReached();
    error ETHNotAccepted();
    error AlreadyRefunded();
    error NothingToRefund(address user);
    error RefundFailed();
    error FundsAlreadyClaimed();
    error ClaimTransferFailed();
    error InvalidSwapAmount(uint256);
    error NoHarvestedYield();
    error NoYieldToClaim();
    error YieldAlreadyClaimed();
    error YieldShareAlreadyCalculated();
    error WeightedContributionsNotCalculated();

    /**
     * @dev Creates a new campaign with specified parameters
     * @param _owner Address of the campaign owner
     * @param _campaignToken Address of the token being collected
     * @param _campaignGoalAmount Goal amount to raise
     * @param _campaignDuration Duration of campaign in days
     * @param _defiManager Address of the DeFi integration manager
     * @param _platformAdmin Address of the platform admin
     */
    constructor(
        address _owner,
        address _campaignToken,
        uint256 _campaignGoalAmount,
        uint256 _campaignDuration,
        address _defiManager,
        address _platformAdmin
    ) Ownable(_owner) PlatformAdminAccessControl(_platformAdmin) {
        if (_campaignToken == address(0)) revert InvalidAddress();
        if (_defiManager == address(0)) revert InvalidAddress();

        defiManager = IDefiIntegrationManager(_defiManager);

        ITokenRegistry tokenRegistry = defiManager.tokenRegistry();

        if (!tokenRegistry.isTokenSupported(_campaignToken)) {
            revert ContributionTokenNotSupported(_campaignToken);
        }

        if (_campaignGoalAmount == 0)
            revert InvalidGoalAmount(_campaignGoalAmount);
        if (_campaignDuration == 0)
            revert InvalidCampaignDuration(_campaignDuration);

        campaignToken = _campaignToken;
        campaignGoalAmount = _campaignGoalAmount;
        campaignDuration = uint64(_campaignDuration);

        campaignStartTime = uint64(block.timestamp);
        campaignEndTime = uint64(
            campaignStartTime + (_campaignDuration * 1 days)
        );

        campaignId = keccak256(
            abi.encodePacked(
                _owner,
                _campaignToken,
                _campaignGoalAmount,
                _campaignDuration,
                campaignStartTime,
                block.number
            )
        );
    }

    /**
     * @dev Fallback function to reject direct ETH transfers
     */
    receive() external payable {
        revert ETHNotAccepted();
    }

    /**
     * @dev Allows a user to contribute to the campaign
     * @param fromToken Address of the token being contributed
     * @param amount Amount to contribute
     *
     * If fromToken matches campaignToken, the contribution is direct.
     * Otherwise, the token is swapped to the campaign token.
     * Records contribution timestamp for time-weighted yield calculation.
     */
    function contribute(
        address fromToken,
        uint256 amount
    ) external nonReentrant {
        if (amount == 0) revert InvalidContributionAmount(amount);
        if (!isCampaignActive()) revert CampaignNotActive();
        if (totalAmountRaised >= campaignGoalAmount)
            revert CampaignGoalReached();

        ITokenRegistry tokenRegistry = defiManager.tokenRegistry();
        if (!tokenRegistry.isTokenSupported(fromToken)) {
            revert ContributionTokenNotSupported(fromToken);
        }

        uint256 contributionAmount;

        if (fromToken == campaignToken) {
            contributionAmount = amount;
            contributions[msg.sender] += contributionAmount;
            totalAmountRaised += contributionAmount;

            IERC20(campaignToken).safeTransferFrom(
                msg.sender,
                address(this),
                amount
            );
        } else {
            IERC20(fromToken).safeTransferFrom(
                msg.sender,
                address(this),
                amount
            );
            IERC20(fromToken).safeIncreaseAllowance(
                address(defiManager),
                amount
            );

            uint256 received = defiManager.swapTokenForTarget(
                fromToken,
                amount,
                campaignToken
            );
            contributionAmount = received;

            contributions[msg.sender] += contributionAmount;
            totalAmountRaised += contributionAmount;

            emit TokensSwapped(fromToken, campaignToken, amount, received);
        }

        // Record contribution timestamp for time-weighted yield calculation
        contributionTimestamps[msg.sender] = block.timestamp;

        // Add to contributors list if first contribution
        if (!isContributor[msg.sender]) {
            isContributor[msg.sender] = true;
            contributors.push(msg.sender);
        }

        emit Contribution(msg.sender, contributionAmount);
    }

    /**
     * @dev Allows contributors to request a refund if campaign fails to reach its goal
     * Can only be called after campaign ends and if the goal was not reached
     */
    function requestRefund() external nonReentrant {
        if (isCampaignActive()) revert CampaignStillActive();
        if (totalAmountRaised >= campaignGoalAmount)
            revert CampaignGoalReached();

        if (hasBeenRefunded[msg.sender]) revert AlreadyRefunded();

        uint256 refundAmount = contributions[msg.sender];
        if (refundAmount == 0) revert NothingToRefund(msg.sender);

        hasBeenRefunded[msg.sender] = true;
        contributions[msg.sender] = 0;

        IERC20(campaignToken).safeTransfer(msg.sender, refundAmount);

        emit RefundIssued(msg.sender, refundAmount);
    }

    /**
     * @dev Allows the campaign owner to claim funds after successful campaign
     * Can only be called after campaign ends and if the goal was reached
     */
    function claimFunds() external onlyOwner nonReentrant {
        if (isCampaignActive()) revert CampaignStillActive();
        if (totalAmountRaised < campaignGoalAmount)
            revert CampaignGoalNotReached();
        if (isClaimed) revert FundsAlreadyClaimed();

        uint256 balance = IERC20(campaignToken).balanceOf(address(this));
        isClaimed = true;

        IERC20(campaignToken).safeTransfer(owner(), balance);

        emit FundsClaimed(owner(), balance);
    }

    /**
     * @dev Deposits funds to a yield-generating protocol
     * @param token Address of the token to deposit
     * @param amount Amount to deposit
     * Can only be called by campaign owner and only while campaign is active
     */
    function depositToYieldProtocol(
        address token,
        uint256 amount
    ) external onlyOwner nonReentrant {
        if (!isCampaignActive()) revert CampaignNotActive();

        IERC20(token).safeIncreaseAllowance(address(defiManager), amount);

        defiManager.depositToYieldProtocol(token, amount);
        emit FundsDeposited(token, amount);
    }

    /**
     * @dev Harvests yield from a protocol
     * @param token Address of the token to harvest yield for
     * Can be called by campaign owner at any time
     */
    function harvestYield(address token) external onlyOwner nonReentrant {
        (uint256 _contributorYield, ) = defiManager.harvestYield(token);
        totalHarvestedYield += _contributorYield;
        emit YieldHarvested(token, _contributorYield);
    }

    /**
     * @dev Allows platform admin to harvest yield after grace period
     * @param token Address of the token to harvest yield for
     */
    function harvestYieldAdmin(
        address token
    ) external onlyPlatformAdminAfterGrace nonReentrant {
        (uint256 _contributorYield, ) = defiManager.harvestYield(token);
        totalHarvestedYield += _contributorYield;
        emit YieldHarvested(token, _contributorYield);
    }

    /**
     * @dev Withdraws all funds from a yield protocol
     * @param token Address of the token to withdraw
     * Can be called by campaign owner
     */
    function withdrawAllFromYieldProtocol(
        address token
    ) external onlyOwner nonReentrant {
        uint256 withdrawn = defiManager.withdrawAllFromYieldProtocol(token);
        emit WithdrawnFromYield(token, withdrawn);
    }

    /**
     * @dev Allows platform admin to withdraw all funds from yield protocol after grace period
     * @param token Address of the token to withdraw
     */
    function withdrawAllFromYieldProtocolAdmin(
        address token
    ) external onlyPlatformAdminAfterGrace nonReentrant {
        uint256 withdrawn = defiManager.withdrawAllFromYieldProtocol(token);
        emit WithdrawnFromYield(token, withdrawn);
    }

    /**
     * @dev Withdraws specific amount from a yield protocol
     * @param token Address of the token to withdraw
     * @param amount Amount to withdraw
     * Can be called by campaign owner
     */
    function withdrawFromYieldProtocol(
        address token,
        uint256 amount
    ) external onlyOwner nonReentrant {
        uint256 withdrawn = defiManager.withdrawFromYieldProtocol(
            token,
            amount
        );
        emit WithdrawnFromYield(token, withdrawn);
    }

    /**
     * @dev Allows platform admin to withdraw specific amount from yield protocol after grace period
     * @param token Address of the token to withdraw
     * @param amount Amount to withdraw
     */
    function withdrawFromYieldProtocolAdmin(
        address token,
        uint256 amount
    ) external onlyPlatformAdminAfterGrace nonReentrant {
        uint256 withdrawn = defiManager.withdrawFromYieldProtocol(
            token,
            amount
        );
        emit WithdrawnFromYield(token, withdrawn);
    }

    /**
     * @dev Calculates the time-based weight for a contributor's yield share
     * @param contributor Address of the contributor
     * @return Weight multiplier (scaled by 100)
     *
     * Weight multipliers:
     * - First 25% of campaign: 1.5x (150)
     * - 25-50% of campaign: 1.25x (125)
     * - 50-75% of campaign: 1.1x (110)
     * - Last 25% of campaign: 1.0x (100)
     */
    function calculateTimeWeight(
        address contributor
    ) internal view returns (uint256) {
        if (isCampaignActive()) revert CampaignStillActive();

        if (!isContributor[contributor] || contributions[contributor] == 0) {
            return 0;
        }

        uint256 contributionTime = contributionTimestamps[contributor];
        if (contributionTime == 0) return 0;

        uint256 campaignDurationSoFar = contributionTime - campaignStartTime;
        uint256 totalDuration = campaignEndTime - campaignStartTime;

        uint256 percentageThrough = (campaignDurationSoFar * 100) /
            totalDuration;

        if (percentageThrough < 25) {
            return 150; // 1.5x weight (scaled by 100)
        } else if (percentageThrough < 50) {
            return 125; // 1.25x weight
        } else if (percentageThrough < 75) {
            return 110; // 1.1x weight
        } else {
            return 100; // 1.0x weight (no bonus)
        }
    }

    /**
     * @dev Calculates the weighted contributions for all contributors
     * This is a one-time calculation after campaign ends to optimize gas costs
     * Must be called before any yield can be claimed
     */
    function calculateWeightedContributions() public {
        if (isCampaignActive()) revert CampaignStillActive();
        if (weightedContributionsCalculated)
            revert YieldShareAlreadyCalculated();

        totalWeightedContributions = 0;

        for (uint256 i = 0; i < contributors.length; i++) {
            address contributor = contributors[i];
            if (contributions[contributor] == 0) continue;

            uint256 timeWeight = calculateTimeWeight(contributor);
            uint256 weighted = (contributions[contributor] * timeWeight) / 100;

            weightedContributions[contributor] = weighted;
            totalWeightedContributions += weighted;
        }

        weightedContributionsCalculated = true;

        emit YieldSharesCalculated();
    }

    /**
     * @dev Calculates a contributor's share of the total yield
     * @return Yield amount the caller is entitled to
     * Requires weighted contributions to be calculated first
     */
    function calculateYieldShare() public view returns (uint256) {
        if (!weightedContributionsCalculated) {
            revert WeightedContributionsNotCalculated();
        }

        if (weightedContributions[msg.sender] == 0) return 0;

        return
            (totalHarvestedYield * weightedContributions[msg.sender]) /
            totalWeightedContributions;
    }

    /**
     * @dev Allows a contributor to claim their share of the yield
     * Can only be called once per contributor after campaign ends
     * Requires weighted contributions to be calculated first
     */
    function claimYield() external nonReentrant {
        if (isCampaignActive()) revert CampaignStillActive();

        if (!weightedContributionsCalculated)
            revert WeightedContributionsNotCalculated();

        if (!isContributor[msg.sender] || contributions[msg.sender] == 0) {
            revert NoYieldToClaim();
        }

        if (hasClaimedYield[msg.sender]) {
            revert YieldAlreadyClaimed();
        }

        if (totalHarvestedYield == 0) {
            revert NoHarvestedYield();
        }

        uint256 yieldShare = calculateYieldShare();
        if (yieldShare == 0) {
            revert NoYieldToClaim();
        }

        hasClaimedYield[msg.sender] = true;

        IERC20(campaignToken).safeTransfer(msg.sender, yieldShare);

        emit YieldDistributed(msg.sender, yieldShare);
    }

    /**
     * @dev Checks if the campaign is currently active
     * @return True if campaign is active, false otherwise
     */
    function isCampaignActive() public view returns (bool) {
        return (block.timestamp >= campaignStartTime &&
            block.timestamp < campaignEndTime);
    }

    /**
     * @dev Checks if the campaign has reached its goal
     * @return True if goal reached, false otherwise
     */
    function isCampaignSuccessful() public view returns (bool) {
        return totalAmountRaised >= campaignGoalAmount;
    }

    /**
     * @dev Gets the amount deposited to yield protocols
     * @param token Address of the token to check
     * @return Amount deposited
     */
    function getDepositedAmount(address token) external view returns (uint256) {
        return defiManager.getDepositedAmount(address(this), token);
    }

    /**
     * @dev Gets the current yield rate from the DeFi protocol
     * @param token Address of the token to check yield rate for
     * @return Current yield rate
     */
    function getCurrentYieldRate(
        address token
    ) external view returns (uint256) {
        return defiManager.getCurrentYieldRate(token);
    }

    /**
     * @dev Gets the total number of contributors to the campaign
     * @return Number of contributors
     */
    function getContributorsCount() external view returns (uint256) {
        return contributors.length;
    }
}
